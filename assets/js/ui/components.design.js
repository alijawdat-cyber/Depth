(function(){
  const NS = window.UIComponents; if (!NS) return;
  // Parsers
  NS.extractColorTokens = function(cssText){ const colors=[]; const lines=(cssText||'').split(/\n|;|\r/); const colorRe=/(#[0-9a-fA-F]{3,8})|rgb[a]?\([^\)]*\)|hsl[a]?\([^\)]*\)/; const seen=new Set(); lines.forEach(line=>{ const m=colorRe.exec(line); if (!m) return; const nameMatch=/(--[\w-]+)\s*:\s*/.exec(line); const name = nameMatch ? nameMatch[1] : (line.trim().split(':')[0]||'').trim(); const value=m[0]; if (value){ const k=`${name}|${value}`; if (!seen.has(k)) { colors.push({name,value}); seen.add(k);} } }); return colors.slice(0,64); };
  NS.extractTypographyStacks = function(cssText){ const stacks={ ar:'', en:'' }; const ar=/font-ar\s*:\s*([^;\n]+)/i.exec(cssText||''); const en=/font-en\s*:\s*([^;\n]+)/i.exec(cssText||''); if (ar) stacks.ar=ar[1].trim(); if (en) stacks.en=en[1].trim(); return stacks; };
  NS.extractShadowTokens = function(cssText){ const res=[]; const lines=(cssText||'').split(/\n|;|\r/); lines.forEach(line=>{ if (/shadow\s*:\s*/i.test(line)) { const nameMatch=/(--[\w-]+)\s*:\s*/.exec(line); const name=nameMatch?nameMatch[1]:'shadow'; const value=line.split(':').slice(1).join(':').trim(); if (value) res.push({name,value}); } }); if (!res.length) { const m=/--shadow\s*:\s*([^;\n]+)/i.exec(cssText||''); if (m) res.push({ name:'--shadow', value:m[1].trim() }); } return res.slice(0,12); };
  NS.extractSpacingTokens = function(cssText){ const res=[]; const lines=(cssText||'').split(/\n|;|\r/); lines.forEach(line=>{ const m=/(\-\-space[-\w]*)\s*:\s*([0-9.]+)px/i.exec(line); if (!m) return; const name=m[1]; const px=parseFloat(m[2]); if (!isNaN(px)) res.push({name,px}); }); return res.sort((a,b)=>a.px-b.px).slice(0,16); };
  NS.extractRadiusTokens = function(cssText){ const res=[]; const lines=(cssText||'').split(/\n|;|\r/); lines.forEach(line=>{ const m=/(\-\-radius[-\w]*)\s*:\s*([0-9.]+)px/i.exec(line); if (!m) return; const name=m[1]; const px=parseFloat(m[2]); if (!isNaN(px)) res.push({name,px}); }); return res.sort((a,b)=>a.px-b.px).slice(0,12); };
  NS.extractBreakpoints = function(cssText){ const res=[]; const lines=(cssText||'').split(/\n|;|\r/); lines.forEach(line=>{ const m=/(\-\-bp[-\w]*)\s*:\s*([0-9.]+)px/i.exec(line); if (!m) return; const name=m[1]; const px=parseFloat(m[2]); if (!isNaN(px)) res.push({name,px}); }); return res.sort((a,b)=>a.px-b.px).slice(0,8); };
  // Renderers
  NS.renderColorPalette = function(colors){ const grid=document.createElement('div'); grid.className='token-palette'; const contrastRatio=(hex)=>{ const parse=(c)=>{ const ctx=NS._c2d || (NS._c2d=document.createElement('canvas').getContext('2d')); try{ ctx.fillStyle=c; }catch{ ctx.fillStyle='#000'; } const s=ctx.fillStyle; const m=/rgba?\((\d+),\s*(\d+),\s*(\d+)/.exec(s); if (!m) return {r:0,g:0,b:0}; return { r:parseInt(m[1]), g:parseInt(m[2]), b:parseInt(m[3]) }; }; const {r,g,b}=parse(hex); const lum=(v)=>{ v/=255; return v<=0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); }; const L=0.2126*lum(r)+0.7152*lum(g)+0.0722*lum(b); const cW=(1+0.05)/(L+0.05); const cB=(L+0.05)/(0+0.05); return cB>cW ? {color:'#000', ratio:cB} : {color:'#fff', ratio:cW}; };
    colors.forEach(({name,value})=>{ const card=document.createElement('div'); card.className='token-swatch'; const header=document.createElement('div'); header.className='swatch-color'; header.style.background=value; const cr=contrastRatio(value); header.style.color=cr.color; header.textContent=value; const body=document.createElement('div'); body.className='swatch-meta'; const n=document.createElement('div'); n.className='swatch-name'; n.textContent=name||'color'; const copy=document.createElement('button'); copy.type='button'; copy.className='swatch-copy'; copy.setAttribute('aria-label','نسخ اللون'); copy.innerHTML='<i data-lucide="copy"></i>'; copy.addEventListener('click', async (e)=>{ e.preventDefault(); try{ await navigator.clipboard.writeText(value); copy.classList.add('copied'); setTimeout(()=>copy.classList.remove('copied'), 1000); }catch(_){} }); body.appendChild(n); body.appendChild(copy); card.appendChild(header); card.appendChild(body); grid.appendChild(card); }); if (window.lucide && window.lucide.createIcons) window.lucide.createIcons(); return grid; };
  NS.renderShadowGrid = function(shadows){ const grid=document.createElement('div'); grid.className='shadow-grid'; shadows.forEach(({name,value})=>{ const card=document.createElement('div'); card.className='shadow-card'; const box=document.createElement('div'); box.className='shadow-box'; box.style.boxShadow=value; const meta=document.createElement('div'); meta.className='shadow-meta'; meta.textContent=`${name}: ${value}`; card.appendChild(box); card.appendChild(meta); grid.appendChild(card); }); return grid; };
  NS.renderTypographyPreview = function(stacks){ const wrap=document.createElement('div'); wrap.className='typography-preview'; const mk=(label,stack,sample,dir='rtl')=>{ if (!stack) return null; const card=document.createElement('div'); card.className='typo-card'; const title=document.createElement('div'); title.className='typo-title'; title.textContent=`${label}`; const text=document.createElement('div'); text.className='typo-sample'; text.textContent=sample; text.style.fontFamily=stack; text.setAttribute('dir', dir); const stackEl=document.createElement('div'); stackEl.className='typo-stack'; stackEl.textContent=stack; card.appendChild(title); card.appendChild(text); card.appendChild(stackEl); return card; }; const ar=mk('Arabic', stacks.ar, 'مثال نص عربي — وزن عادي 16px، للمعاينة.', 'rtl'); const en=mk('English', stacks.en, 'The quick brown fox jumps over the lazy dog. 16px regular.', 'ltr'); ar && wrap.appendChild(ar); en && wrap.appendChild(en); return wrap; };
  NS.renderSpacingGrid = function(spaces){ const wrap=document.createElement('div'); wrap.className='spacing-grid'; const max=Math.max(...spaces.map(s=>s.px),1); spaces.forEach(({name,px})=>{ const row=document.createElement('div'); row.className='spacing-item'; const label=document.createElement('div'); label.className='spacing-label'; label.textContent=`${name}`; const bar=document.createElement('div'); bar.className='spacing-bar'; bar.style.width=`${Math.max(8,(px/max)*100)}%`; const val=document.createElement('div'); val.className='spacing-value'; val.textContent=`${px}px`; row.appendChild(label); row.appendChild(bar); row.appendChild(val); wrap.appendChild(row); }); return wrap; };
  NS.renderRadiusGrid = function(radii){ const grid=document.createElement('div'); grid.className='radius-grid'; radii.forEach(({name,px})=>{ const card=document.createElement('div'); card.className='radius-card'; const box=document.createElement('div'); box.className='radius-box'; box.style.borderRadius=`${px}px`; const meta=document.createElement('div'); meta.className='radius-meta'; meta.textContent=`${name}: ${px}px`; card.appendChild(box); card.appendChild(meta); grid.appendChild(card); }); return grid; };
  NS.renderBreakpoints = function(bps){ const row=document.createElement('div'); row.className='bp-chips'; const max=Math.max(...bps.map(b=>b.px),1); bps.forEach(({name,px})=>{ const chip=document.createElement('div'); chip.className='bp-chip'; const title=document.createElement('div'); title.className='bp-name'; title.textContent=name; const preview=document.createElement('div'); preview.className='bp-preview'; preview.style.width=`${Math.max(20,(px/max)*100)}%`; const v=document.createElement('div'); v.className='bp-value'; v.textContent=`${px}px`; chip.appendChild(title); chip.appendChild(preview); chip.appendChild(v); row.appendChild(chip); }); return row; };
  // حافظة صغيرة للألوان على عناصر فيها data-color
  NS.annotateColorChips = function(rootEl){ try{ const root=rootEl||document.getElementById('doc-content'); if(!root) return; const chips=root.querySelectorAll('[data-color], .color-chip'); chips.forEach(ch=>{ const color=ch.getAttribute('data-color')||ch.dataset.color||''; if(!color) return; ch.style.setProperty('--chip-color', color); if(!ch.classList.contains('color-chip')) ch.classList.add('color-chip'); const cs=getComputedStyle(ch).backgroundColor; if(!cs || cs==='rgba(0, 0, 0, 0)'){ ch.style.background=color; ch.style.borderRadius='999px'; ch.style.display='inline-block'; ch.style.width=ch.style.width||'12px'; ch.style.height=ch.style.height||'12px'; ch.style.verticalAlign='middle'; ch.style.marginInlineStart=ch.style.marginInlineStart||'6px'; } ch.setAttribute('title', color); }); }catch(_){} };
  // Enhancer
  NS.enhanceDesignTokens = function(rootEl){
    const root = rootEl || document.getElementById('doc-content'); if (!root) return;
    const findCodeAfterHeading = (includesText) => { const heads = Array.from(root.querySelectorAll('h2, h3')); const target = heads.find(h => (h.textContent || '').toLowerCase().includes(includesText)); if (!target) return null; let el = target.nextElementSibling; while (el) { if (el.matches('pre') && el.querySelector('code')) return el.querySelector('code'); if (/^H[1-6]$/.test(el.tagName)) break; el = el.nextElementSibling; } return null; };
    try { const colorCode = findCodeAfterHeading('tokens — colors'); if (colorCode) { const text = colorCode.textContent || ''; const colors = NS.extractColorTokens(text); if (colors.length) { const palette = NS.renderColorPalette(colors); const hostPre = colorCode.closest('pre'); hostPre && hostPre.after(palette); } } } catch(_){ }
    try { const typoCode = findCodeAfterHeading('tokens — typography'); if (typoCode) { const text = typoCode.textContent || ''; const stacks = NS.extractTypographyStacks(text); if (stacks && (stacks.ar || stacks.en)) { const demo = NS.renderTypographyPreview(stacks); const hostPre = typoCode.closest('pre'); hostPre && hostPre.after(demo); } } else { const lis = Array.from(root.querySelectorAll('li')); const stacks = { ar:'', en:'' }; lis.forEach(li => { const t=(li.textContent||'').trim(); if (t.toLowerCase().startsWith('arabic:')) stacks.ar = t.split(':').slice(1).join(':').trim(); if (t.toLowerCase().startsWith('english:')) stacks.en = t.split(':').slice(1).join(':').trim(); }); if (stacks.ar || stacks.en) { const demo = NS.renderTypographyPreview(stacks); const anyLi = lis[0] && lis[0].closest('ul, ol'); anyLi && anyLi.after(demo); } } } catch(_){ }
    try { const elevCode = findCodeAfterHeading('tokens — spacing & radius') || findCodeAfterHeading('tokens — elevation') || findCodeAfterHeading('elevation'); const firstCssCode = elevCode || root.querySelector('pre code.language-css, pre code[class*="css"]'); if (firstCssCode) { const text = firstCssCode.textContent || ''; const shadows = NS.extractShadowTokens(text); if (shadows.length) { const grid = NS.renderShadowGrid(shadows); const hostPre = firstCssCode.closest('pre'); hostPre && hostPre.after(grid); } const spaces = NS.extractSpacingTokens(text); if (spaces.length) { const grid = NS.renderSpacingGrid(spaces); const hostPre = firstCssCode.closest('pre'); hostPre && hostPre.after(grid); } const radii = NS.extractRadiusTokens(text); if (radii.length) { const grid = NS.renderRadiusGrid(radii); const hostPre = firstCssCode.closest('pre'); hostPre && hostPre.after(grid); } } } catch(_){ }
    try { const bpCode = findCodeAfterHeading('tokens — breakpoints') || root.querySelector('pre code.language-css, pre code[class*="css"]'); if (bpCode) { const text = bpCode.textContent || ''; const bps = NS.extractBreakpoints(text); if (bps.length) { const row = NS.renderBreakpoints(bps); const hostPre = bpCode.closest('pre'); hostPre && hostPre.after(row); } } } catch(_){ }
  };
})();
